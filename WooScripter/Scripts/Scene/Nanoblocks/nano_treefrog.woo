rule main {
//call (babyduck)
call(treefrog)
}

rule treefrog {
pos += vec(-6, 0, -6)

diff = vec(1, 1, 1)
v1 = vec(7, 6, 0) call(nano4x2)

pos.y += 0.78
diff = vec(1, 1, 1)
v1 = vec(5, 5, 0) call(nano1x4)
v1 = vec(6, 6, 0) call(nano4x2)
diff = vec(0.2, 1, 0.2)
v1 = vec(10, 6, 0) call(nano2x2)

pos.y += 0.78
diff = vec(1, 1, 1)
v1 = vec(4, 6, 0) call(nano4x2)
v1 = vec(5, 4, 0) call(nano1x2)
v1 = vec(5, 8, 0) call(nano1x2)
v1 = vec(8, 6, 0) call(nano1x2)
diff = vec(0.2, 1, 0.2)
v1 = vec(9, 4, 0) call(nano2x2)
v1 = vec(9, 6, 0) call(nano2x2)
v1 = vec(9, 8, 0) call(nano2x2)
v1 = vec(11, 4, 0) call(nano1x3)
v1 = vec(11, 7, 0) call(nano1x3)
v1 = vec(12, 6, 0) call(nano1x2)

pos.y += 0.78
diff = vec(1, 1, 1)
v1 = vec(3, 6, 0) call(nano2x1)
v1 = vec(3, 7, 0) call(nano2x1)
v1 = vec(5, 5, 0) call(nano2x4)
v1 = vec(7, 5, 0) call(nano1x2)
v1 = vec(7, 7, 0) call(nano1x2)
diff = vec(0.2, 1, 0.2)
v1 = vec(8, 3, 0) call(nano2x4)
v1 = vec(8, 7, 0) call(nano2x4)
v1 = vec(10, 3, 0) call(nano1x3)
v1 = vec(10, 6, 0) call(nano1x2)
v1 = vec(10, 8, 0) call(nano1x3)
v1 = vec(11, 5, 0) call(nano2x4)

pos.y += 0.78
diff = vec(1, 1, 1)
v1 = vec(1, 6, 0) call(nano1x2)
v1 = vec(3, 4, 0) call(nano2x1)
v1 = vec(3, 9, 0) call(nano2x1)
v1 = vec(2, 5, 0) call(nano4x2)
v1 = vec(2, 7, 0) call(nano4x2)
diff = vec(0.2, 1, 0.2)
v1 = vec(6, 4, 0) call(nano4x2)
v1 = vec(6, 6, 0) call(nano4x2)
v1 = vec(6, 8, 0) call(nano4x2)
v1 = vec(10, 5, 0) call(nano2x4)

pos.y += 0.78
v1 = vec(1, 6, 0) call(nano2x2)
v1 = vec(2, 5, 0) call(nano1x1)
v1 = vec(2, 8, 0) call(nano1x1)
v1 = vec(3, 4, 0) call(nano2x4)
v1 = vec(3, 8, 0) call(nano2x2)
v1 = vec(5, 5, 0) call(nano4x2)
v1 = vec(5, 7, 0) call(nano4x2)
v1 = vec(9, 6, 0) call(nano2x2)

pos.y += 0.78
diff = vec(0.2, 0.2, 0.2)
v1 = vec(3, 5, 0) call(nano1x1c)
v1 = vec(3, 8, 0) call(nano1x1c)
diff = vec(0.2, 1, 0.2)
v1 = vec(2, 6, 0) call(nano4x2)
v1 = vec(6, 6, 0) call(nano4x2)
v1 = vec(4, 5, 0) call(nano2x1)
v1 = vec(4, 8, 0) call(nano2x1)

pos.y += 0.78
diff = vec(0.2, 1, 0.2)
v1 = vec(3, 5, 0) call(nano1x1c)
v1 = vec(3, 8, 0) call(nano1x1c)
v1 = vec(5, 6, 0) call(nano2x2)

pos.y -= 0.78 * 6
diff = vec(0.2, 1, 0.2)
pos += vec(9, 0, 4)
ry -= 150 v1 = vec(0, 0, 0) call(nano2x1) ry += 150


}

rule babyduck {
pos += vec(-6, 0, -6)

diff = vec(0.3, 1, 0.3)
v1 = vec(1,1,0) call(nano10x10)

pos.y += 0.78
diff = vec(1,0.5,0)
v1 = vec(5, 3, 0) call(nano2x1)
v1 = vec(5, 4, 0) call(nano2x1)

pos.y += 0.78
v1 = vec(6, 3, 0) call(nano1x1c)
v1 = vec(6, 4, 0) call(nano1x1c)

pos.y += 0.78
diff = vec(1, 1, 0.0)
v1 = vec(4.5, 3, 0) call(nano4x2)

pos.y += 0.78
v1 = vec(3.5, 3, 0) call(nano4x2)
diff = vec(1,1,1)
v1 = vec(7.5, 3, 0) call(nano2x2)

pos.y += 0.78
diff = vec(1, 1, 0.0)
v1 = vec(3.5, 3, 0) call(nano1x2)
v1 = vec(5.5, 3, 0) call(nano1x2)
v1 = vec(6.5, 3, 0) call(nano2x2)

pos.y += 0.78
diff = vec(1, 0.5, 0)
v1 = vec(1, 3.5, 0) call(nano2x1)
diff = vec(1, 1, 0)
v1 = vec(3, 3, 0) call(nano2x2)

pos.y += 0.78
v1 = vec(2, 3, 0) call(nano1x2)
diff = vec(0.3, 0.3, 0.3)
v1 = vec(3, 3, 0) call(nano1x1c)
v1 = vec(3, 4, 0) call(nano1x1c)
diff = vec(1, 1, 0.0)
v1 = vec(4, 3, 0) call(nano1x2)

pos.y += 0.78
v1 = vec(2, 3, 0) call(nano2x2)
}


rule nano1x1 {
v0 = vec(1,1,0) call(nanobox)
}

rule nano10x10 {
v0 = vec(10,10,0) call(nanobox)
}

rule nano2x2 {
v0 = vec(2,2,0) call(nanobox)
}

rule nano2x1 {
v0 = vec(2,1,0) call(nanobox)
}

rule nano1x2 {
v0 = vec(1,2,0) call(nanobox)
}

rule nano4x2 {
v0 = vec(4,2,0) call(nanobox)
}

rule nano2x4 {
v0 = vec(2,4,0) call(nanobox)
}

rule nano4x1 {
v0 = vec(4,1,0) call(nanobox)
}

rule nano1x4 {
v0 = vec(1,4,0) call(nanobox)
}

rule nano3x1 {
v0 = vec(3,1,0) call(nanobox)
}

rule nano1x3 {
v0 = vec(1,3,0) call(nanobox)
}

rule nano1x1c
{
push()
pos.x += v1.x pos.z += v1.y

scale = vec(0.97, 0.775, 0.97)
call(cylinder)
pos.y += 1
scale = vec(1,1,1)
call(nanocyl)

pop()
}

rule nano2x1s
{
ry -= 90
call(nano1x2s)
}

rule nano1x2s
{
push()
pos.x += v1.x pos.z += v1.y

pos.z += 0.5
scale = vec(0.97, 0.775, 1.97)
call(box)
scale = vec(1, 1, 1)
pos.z -= 0.5
 
pos.y += 0.775
pos.z += 0.5
call (nanocyl)

pop()
}

rule nanobox
{
push()
pos.x += v1.x pos.z += v1.y

// move middle location
pos.x += (v0.x * 0.5) - 0.5
pos.z += (v0.y * 0.5) - 0.5

// give a bit of noise to the box
scale = vec(v0.x - 0.03, 0.775, v0.y - 0.03)
call(box)

// move to top surface of box
pos.y += 1

// reset for the little nanocylinders
scale = vec(1,1,1)
pos.x -= (v0.x * 0.5) - 0.5
pos.z -= (v0.y * 0.5) - 0.5

// build the nanocylinders
repeat (xcyl, v0.x)

pop()
}

rule xcyl
{
// preserve state between calls
push()
repeat(zcyl, v0.y)
pop()
pos.x += 1
}

rule zcyl
{
call (nanocyl)
pos.z += 1
}

rule nanocyl
{
scale = vec(0.6, 0.39, 0.6)
call(cylinder)
}